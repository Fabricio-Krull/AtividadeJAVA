# AtividadeJAVA
Atividade da criação de produtos
                            O Arquivo Main.java
No início do programa, para uma compreensão mais fácil do código, eu decidi substituir o modelo de leitura por parâmetro, que se assemelha
a isso => objeto.setAtributo(leitura.nextTipoDoAtributo) pela criação de variáveis que possuem o mesmo nome e tipo dos respectivos atributos 
da classe produto.

No primeiro case, eu decidi dar ao usuário o poder de escolher qual construtor usar para instanciar o objeto. Ele pode inicializar o nome, ID, e preço do objeto, ou apenas o nome, ou o nome e o ID somente, ou somente o nome e peso, por exemplo. Agora, caso o usuário não inicialize o ID do objeto, esse deve ser inicializado automaticamente, por padrão, mas isso será discutido na sessão do arquivo Produto.java.
No segundo case, para a edição de um objeto, mais prático que ter que reinicializar todo o objeto, o usuário seleciona qual objeto ele quer editar, e logo após, seleciona qual atributo ele gostaria de editar, exceto pelo ID, que seria a chave primária e o identificador de um produto na vida real, pois vários produtos são semelhantes, mas um ID difere dois produtos iguais. Um atributo novo, descrição, não é inicializado em nenhum dos construtores, mas é acessível através da edição dos atributos do objeto. A edição de um atributo de um objeto é realizada atráves de seu respectivo setter.
No terceiro case, agora, temos a exclusão de um objeto. Esse processo pode parecer complicado, mas existe uma maneira de explicar. Durante os laços for() utilizados para percorrer o array de objetos (para mostrar todos os objetos existentes, como no case 2), não era possível usar essa sintaxe => for(int i = 0; arrayDeObjetos; i++){//comandos aqui}, pois um array de objetos não pode receber um tipo boolean (quando uma variável ou array é colocado dentro de uma cláusula de condição sem nenhum adicional ou operador lógico, ela é interpretada como true), então é utilizada uma condição que verifica se um objeto é igual a null, e caso seja, o array acaba, e o loop encerra. Agora para a exclusão de um objeto, diferente de C++, com os destrutores e o comando delete e delete[], o usuário seleciona qual objeto deseja excluir, e o objeto no índice escolhido recebe o valor null. Após a exclusão, um laço for() reorganiza o array, impedindo que sobre espaços em branco. E funciona da seguinte forma: Caso a casa atrás da posição em que estamos iterando seja nula, então:
1- Ela recebe o valor da casa atual, neste caso: i-1 = i;
2- A casa atual recebe o valor null, para que a próxima casa realize o mesmo que a casa anterior. Neste caso, na próxima iteração, a casa i será a da casa após a casa que recebeu o null, então, a casa i atual irá para o null, e então i se tornará null. Isso organiza todo o array automaticamente.
No quarto case, por mais que seja o mais simples, foi o que mais demorou a funcionar, pois os getters utilizados para exibir os dados estavam retornando null, não lembro o motivo agora. Ele simplesmente mostra todos os dados de um elemento, destacando o nome.

                        O Arquivo Produto.java
No início do arquivo, todos os atributos são declarados, e um comentário está presente na declaração do atributo ID, que diz "Não consegui criar um inicializador padrão para o ID, eu vou tentar fazer isso mais tarde". Agora, isto é, eu decidi que você não pode alterar o ID de um produto, mas caso você não inicialize o valor de ID no construtor, esse ficaria vazio para sempre (isto é, muito tempo!), e não seria possível editá-lo. Então, eu decidi dar um valor padrão ao ID de todos os objetos, 1000. Caso o usuário informasse ao programa qual ID ele gostaria de dar ao produto, o construtor inicializaria o ID com o valor passado, mas caso o usuário não inicializasse o ID do produto, todos os produtos compartilhariam um mesmo ID 1000, mas a cada produto inicializado sem um ID, o valor de ID era incrementado em 1. Porém, não foi possível trabalhar nesta solução, que requeria o uso de variáveis estáticas, o que sinceramente eu não sei manipular bem em Java (C++ é bem melhor!). Ainda assim, eu consegui realizar os outros quesitos muito bem.

                        Problemas no programa (ninguém é perfeito)
Um problema que eu acabei não resolvendo, foi a disponibilidade do usuário de acessar o menu de edição, exclusão e lista de objetos antes mesmo de criar um objeto. Por mais que seja um programa de uso simples, essa função seria crucial, mas que infelizmente não foi implementada ao programa.
